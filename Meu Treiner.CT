<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="42">
  <Forms>
    <EditView Class="TCEForm" Encoding="Ascii85">*mUAO8]Tw[wX,]oZUUI3RU=;vp#%{+-Go3NqRRIEWMM/h,AOh1gRaMS=a_K8b.j4b+-*u81qmstC:xv60VQe+h+s%Kr8bWhLE.4wKmwskv?7,Y4,!z2?K%wYJ9Fm8/MFNo-KyEur/pr+=sw03=!D*p?wL5?R4vcs/!WhqhM6nz;4wG@HM,KAo-Xldc[em)YRwjp^$=avW$nn{)I;SAZ$,//WC_,RR%wYD,,=}uN{tq;Mykln1}unYW@[^Nx;i}5aJq7o8r?]FJE_Gligt!dXjS3sI,fG*PL)lT@k!;viL_-KjM%_4F]6{@R327VshLwADJ#M(/sL.is1)/gf?+3VjVYCG8;lME6kSc1bd4I@@+Cj;9gov9.A@hbB4(khIbC=HGWT?pNMWHeT{_4rn9fXjRMi)}BV_3YsUp]CR[igcLSyj=Z8EAnF:zKFYg{!}$**xpF+Q:xsXfZ$U7}AzU6z,lO[@kgCqzhcQ-qVGDNB,8kfag#-/:g#MLG@ocEhuKCGRSpi?%MSBsC-)(fkq2HwI#SeEdGZ65u4?4B^j^yKl3.1Nf4F6}F=ZjXci+T7VY.Cjhf)le]H_75n{Qd4-;,aGWcEF5np*uQ3ca+zk*NFN+6@+!K}D4rn4.:(Km)SrJPy(K8]H1G2uh:sz7_H-o,;v7H4h2JJS@=H;m]1Go%$7w^=IA9)*/z_R0lz{,Es8,b3C5n,d%7XUYgz}2Bb4q;-{._qL)(prdZ4rl^ffGdGMZ),aB0l!DPr4YNf)dRhez^a@.6x)_NM+!yo[TK^bfn5ykeuQ=f1pW5K[ypk3:/@[rFQMI@wy=W@oaeWQ+{JIu/t@.q6L!_#KDYnQkoT97rzGCv+x3-fKcd{}W9QQ@+3UNq]_}(-XK,rw#W{mQh26i:F6oQyH$$u..omz$+j?Jdo(E6a^bGIo1;@Y?.2Pe*3RpmGS?h4b]x5Xz-iy6Zb@P]1(uYj%o+J-@XMJt4j_+Gm2vg*8ycap]Fy/P6-kAmzg$=E%eiM0eAK+NI0e,5Sh/C36YJf{FZro%JcJlfhfMQ-.2mBf@f$gF5]X:Yl@CCvWo/slbza63okrPLWW^A59]Iu4CS%:CAQTAB3?iOaZqWX{;,N]3Qlo{-^AE:qBwAk95Q6-)[A}EH7hZpoUvffF}m+y9#+%1YcJekYq4)0Mv94e]KQm1,xuM/](6-i,w71=POQe$:?71]sKJUc3F%{AAr31eE7NL-RcStbgeQ7T@AM8[SXJr,=4iOR]i#-nt-Y_;6g(RF)NGhQY2W1]{UNKn1#6.4bZkrHq[PmLz?m2Ruj*BK2La8bP2Wst1uMV,Y2J,JJNEw/DtG99XsKCP3XS_]!PyIrlLrLMV328fMO;uspo2g1}j+(X]jj%;5s17UKb(r9g!k6pd.*w4#ktFr-$WjaNhu--x=^}{ECPVCXIIkL?}4}9/hNp$iqZ.BT_C;yw+MZIr-V=678V=@;,[-02O!9y18j+Om=^h!}vWbfTi!e6JEv[+,taWC-EZ4Uf^p@NQu$YQJLtWA}U0}ee1^(=78i?qU,uQt0(_7zQ?(7u#5ivDPz:-TF?YoVgAZ6;/bFM4#FML%S3j4z}K*h^?17G2e8%qz-K%=zefmo{kKX(p]s*y@-]*9!{5+V=-oq,N7rW0ME-xqSY,e:vXl-Pa=:zu]jS@^{n$U%l}*;[J[5S65O5.[7b:RT}(Ahw}=*a{YU!oDaI3i85QGrUHe+Aj,s-E]}=G,aLLf^Qq({Qy^6-qUv(yoldKDkrNjfCmav1tfTG?YrU48M1IPZce@mZ]o]5uOldG;Rh$rUD8yRCXj1uhKcoH3,jFtr)UWSuNOXN)GjQx5@p4G*v7d6s(VX?=C:H[2nNGZ6cX=F7L1o]8CUyJ7EodvDlNtS.*IXaC4(4g-DB*D9]S3.m5DHT}VFjIc2WK2vx8K]z=ZB!pAl-sTw{0{Mij!T@N57V}K8vf:1S(Q-QnM!OI.GHafhF}@*R*4d6SqWmh@ck(i^,/1d)%B^vfds^,vdUj7a+0?y6=+%z(g;-nnC+?ZKBUtw.Bzy*/S)1:0VbAFKJw?]*m4M,UPH)e%;+sN02$y$LufQ0=coQGuu6a%._9ES{5{en:sdc%$dH!!a62rNw/kr$X{(i]Y#;(w!7AM+,.9?Ntx.Dde2$m5e5ezlNYs*220q#)[+@iX;g-GU:5yjj+FbP)I6vz[l??H_284nAEMFE0txBwPD}HGvQl:PTr==J4kV:n(:$L#Gvl@8H?xtQ$OjJiA6oQxI#FYTr[B1DMN@mM-F:,ab8psm,QO;Z3N?_YX^?^WocIN1mFSTMP,5:UQS0I{PjRnskf#k1*JELvIqCM=/ueSD=Bq?vFa%LHVBGJK$Y)RKo6m$1HGHONZY8OqY%_;6$TwqL8]9WLK0[JX?gCCDoAiFu::Blb,/2B4(P3Juz0UjLPLeXfT[LM/N,UXJX6#18YQS6RKL</EditView>
  </Forms>
  <CheatEntries/>
  <UserdefinedSymbols/>
  <LuaScript>-- Script Edit e View PangYa S8 Ver. [JP/USA] By Acrisio SuperSS Dev
-- Criado em 10/11/2019 as 12:00 por Acrisio
-- Update 22/11/2019 13:54 [Add All Freeze values "Spin, Curva, Vento, Ângulo, Slope X e Slope Y"]
--
MapSearch = {
    state = nil,
    const_addr = 0x00E73E60, -- JP 0x00E73E60 --USA 0x00E3CFD4
    link = {[1] = 0x34, [2] = 0x30, [3] = 0x10, [4] = 0x2c, [5] = 0x18},
    MapEntry = 0,
    pin = {0, 0, 0},
    tee = {0, 0, 0},
    ball_ground = {0, 0},
    ball_effect = {0, 0},
    ball_line = 0,
    ground = 0, -- Terreno
    wind = {0, 0},
    wind_rotate = 0.00,
    mira = 0.00,
    distancia = 0.00,
    altura = 0.00,
    pb = 0.00,
    grid_mira_radiano = 0.00,
    power_gauge = 0.0,
    const_addr_power_gauge = 0xE47E2C, -- JP 0xE47E2C  -- USA 0xE10FAC

    -- acho que e a funcao que inicia
    init = function(self)

        if process then

            self.MapEntry = readInteger(self.const_addr)

            if self.MapEntry and self.MapEntry &gt; 0 then

                for i,v in ipairs(self.link) do

                    if self.MapEntry and self.MapEntry &gt; 0 then
                        self.MapEntry = readInteger(self.MapEntry+v)
                    end
                end
            end

            if self.MapEntry and self.MapEntry &gt; 0 then
                self.state = true
            end
        else
            self.state = nil
        end
    end,
    
    findMap = function(self, name)

        -- Initialize, all time check new values pointers
        self:init()

        mapAllocedElement = 0

        if self.MapEntry and self.MapEntry &gt; 0 then

            while self.MapEntry ~= 0 and mapAllocedElement == 0 do

                if readString(readInteger(self.MapEntry+4), 16) == name then
                    mapAllocedElement = readInteger(self.MapEntry)
                else
                    self.MapEntry = readInteger(self.MapEntry+0x14)
                end
            end
        end

        return mapAllocedElement
    end,
    
    getScreenStruct = function(self)

        st_screen_ptr = self:findMap('Screen')

        if not st_screen_ptr then
            return nil
        else
            return readInteger(st_screen_ptr)
        end
    end,
    getGridStruct = function(self)

        st_grid_ptr = self:findMap('Grid')

        if not st_grid_ptr then
            return nil
        else
            return {
                this = readInteger(st_grid_ptr),
                grid_mira_radiano = 0,
                init = function(self)

                    -- Initialize data
                    if self.this then
                        self.grid_mira_radiano = self.this+0x6944 -- JP 0x6944 -- usa 0x3064
                    else
                        if log then
                            print('Não conseguiu achar o ponteiro do grid. ' .. string.format('%s', self.this))
                        end
                    end
                end
            }
        end
    end,
    getSpinStruct = function(self)

        st_spin_ptr = self:findMap('Spin')

        if not st_spin_ptr then
            return nil
        else
            return {
                this = readInteger(st_spin_ptr),
                curva = 0,
                spin = 0,
                curvaLimit = 0,
                spinLimit = 0,
                init = function(self, option)

                    if self.this then
                        -- Initialize Address
                        self.curva = self.this+0x18
                        self.spin = self.this+0x1C
                        self.curvaLimit = self.this+0x20
                        self.spinLimit = self.this+0x24
                    else
                        if log then
                            print('Não conseguiu achar o ponteiro do spin. ' .. string.format('%s', self.this))
                        end
                    end
                end
            }
        end
    end,
    getSlopGroundStruct = function(self)

        st_screen_ptr = self:getScreenStruct()

        if not st_screen_ptr then
            return nil
        else
            return {
                this = readInteger(st_screen_ptr+0x21C),
                ground_x = 0,
                ground_y = 0,
                ground = 0,
                line_rotate = 0,
                line_size = 0,
                init = function(self, option)

                    if self.this then
                      -- Initialize Address
                      self.ground_x = self.this+0x1C
                      self.ground_y = self.this+0x24
                      self.line_rotate = self.this+0xE8
                      self.line_size = self.this+0x20
                      self.ground = self.this+0xAC
                    else
                        if log then
                            print('Não conseguiu encontrar o ponteiro do Slop Ground. ' .. string.format('%x', self.this))
                        end
                    end
                end
            }
        end
    end,
    getClassicWindStruct = function(self)

        const_addr_wind_ptr = 0x00E79064 -- JP 0x00E79064 0x00E403A4

        array_heap = {
            first_ptr = readInteger(const_addr_wind_ptr),
            table_ptr = 0,
            max_element = 0,
            index_1 = readInteger(const_addr_wind_ptr+0x0C),
            index_2 = readInteger(const_addr_wind_ptr+0x10),
            index = 0,
            address = 0,
            getIndex = function(self)
                if self.index_1 and self.index_2 then
                    return self.index_1 + self.index_2
                else
                    return nil
                end
            end,
            init = function(self)

                -- Verifica se o first ptr é valído
                if self.first_ptr and self.first_ptr &gt; 0 then

                    self.first_ptr = readInteger(self.first_ptr)

                    if self.first_ptr and self.first_ptr &gt; 0 then
                        self.first_ptr = readInteger(self.first_ptr)
                    end

                    -- Index real
                    self.index = self:getIndex() - 1

                    -- Calcular address
                    if self.first_ptr and self.first_ptr &gt; 0 then

                        self.max_element = readInteger('[' .. string.format('%x', self.first_ptr) .. ']+8')

                        if self.index &gt;= self.max_element then
                            self.index = self.index - self.max_element
                        end

                        self.table_ptr = readInteger('[' .. string.format('%x', self.first_ptr) .. ']+4')

                        if self.first_ptr and self.table_ptr &gt; 0 then

                            st = readInteger(self.table_ptr + (self.index * 4))

                            if st and st &gt; 0 then

                                self.address = readInteger(st)
                                self.address = self.address ~ readInteger(st+8)
                                self.address = ~self.address &amp; 0xFFFFFFFF
                            end
                        end

                    end
                end

            end
        }

        array_heap:init()

        if array_heap.address == 0 then
            return nil
        else
            return {
                this = array_heap.address,
                wind_speed = 0,
                wind_direction = 0,
                wind_rotate = 0,
                table_wind_value = nil,
                init = function(self, option)

                    -- Initialize Address
                    self.table_wind_value = {
                        addres_ptr = 0,
                        speed_1 = {0, 0},
                        speed_2 = {0, 0},
                        speed_3 = {0, 0},
                        wind_speed = 0,
                        wind_direction = 0,
                        init = function(self, wind_addr)

                            -- Address
                            table_wind_value_ptr = 0

                            if readBytes(wind_addr+0x170, 1) == 0 then
                                table_wind_value_ptr = wind_addr + 0xD8
                            else
                                table_wind_value_ptr = wind_addr + 0x114
                            end

                            if table_wind_value_ptr ~= 0 then

                                value1 = 0
                                value2 = 0
                                value3 = 0

                                -- Wind Speed
                                self.speed_1[1] = readInteger(table_wind_value_ptr)
                                self.speed_1[2] = readInteger(table_wind_value_ptr+8)

                                self.speed_2[1] = readInteger(table_wind_value_ptr+0x10)
                                self.speed_2[2] = readInteger(table_wind_value_ptr+0x18)

                                self.speed_3[1] = readInteger(table_wind_value_ptr+0x20)
                                self.speed_3[2] = readInteger(table_wind_value_ptr+0x28)

                                value1 = self.speed_1[1] ~ self.speed_1[2]
                                value2 = self.speed_2[1] ~ self.speed_2[2]
                                value3 = self.speed_3[1] ~ self.speed_3[2]

                                value1 = byteTableToFloat(dwordToByteTable(~value1 &amp; 0xFFFFFFFF))
                                value2 = byteTableToFloat(dwordToByteTable(~value2 &amp; 0xFFFFFFFF))
                                value3 = byteTableToFloat(dwordToByteTable(~value3 &amp; 0xFFFFFFFF))

                                value1 = value1 * value1
                                value2 = value2 * value2
                                value3 = value3 * value3

                                self.wind_speed = tonumber(string.format('%.1f', math.sqrt(value1 + value2 + value3)))

                                -- Wind direction
                                cos = self.speed_3[1] ~ self.speed_3[2]
                                sin = self.speed_1[1] ~ self.speed_1[2]

                                sin = byteTableToFloat(dwordToByteTable(~sin &amp; 0xFFFFFFFF))
                                cos = byteTableToFloat(dwordToByteTable(~cos &amp; 0xFFFFFFFF))

                                -- sin, cos
                                if self.wind_speed &gt; 0.0 then
                                    sin = sin / self.wind_speed * -1.0
                                    cos = cos / self.wind_speed
                                end

                                graus_sin = tonumber(string.format('%.2f', math.deg(math.asin(sin))))
                                graus_cos = tonumber(string.format('%.2f', math.deg(math.acos(cos))))

                                if graus_sin &lt; 0.0 then
                                    self.wind_direction = 180.0 - (graus_cos - 180.0)
                                else
                                    self.wind_direction = graus_cos
                                end
                            end
                        end,
                        makeWindAndAng = function(self, wind_addr)

                            table_wind_value_ptr = 0

                            if readBytes(wind_addr+0x170, 1) == 0 then
                                table_wind_value_ptr = wind_addr + 0xD8
                            else
                                table_wind_value_ptr = wind_addr + 0x114
                            end

                            if table_wind_value_ptr ~= 0 then

                                value1 = 0
                                value2 = 0
                                value3 = 0
                                mask1 = 0
                                mask2 = 0
                                mask3 = 0

                                mask1 = table_wind_value_ptr
                                mask2 = table_wind_value_ptr+0x10
                                mask3 = table_wind_value_ptr+0x20

                                ang = self.wind_direction

                                sin = math.sin(math.rad(ang)) * -1.0 -- invert
                                cos = math.cos(math.rad(ang))

                                value1 = self.wind_speed * sin
                                value3 = self.wind_speed * cos

                                value1 = byteTableToDword(floatToByteTable(value1))
                                value3 = byteTableToDword(floatToByteTable(value3))

                                self.speed_1[1] = (~value1 &amp; 0xFFFFFFFF) ~ self.speed_1[2]
                                self.speed_2[1] = (~value2 &amp; 0xFFFFFFFF) ~ self.speed_2[2]
                                self.speed_3[1] = (~value3 &amp; 0xFFFFFFFF) ~ self.speed_3[2]

                                mask1 = mask1 ~ self.speed_1[1]
                                mask2 = mask2 ~ self.speed_2[1]
                                mask3 = mask3 ~ self.speed_3[1]

                                -- test write
                                writeInteger(table_wind_value_ptr, self.speed_1[1])
                                writeInteger(table_wind_value_ptr+4, mask1)
                                writeInteger(table_wind_value_ptr+0x10, self.speed_2[1])
                                writeInteger(table_wind_value_ptr+0x14, mask2)
                                writeInteger(table_wind_value_ptr+0x20, self.speed_3[1])
                                writeInteger(table_wind_value_ptr+0x24, mask3)
                            end
                        end
                    }

                    self.table_wind_value:init(self.this)

                    self.wind_speed = self.table_wind_value.wind_speed
                    self.wind_direction = self.table_wind_value.wind_direction
                    self.wind_rotate = self.this+0x58
                end
            }
        end
    end,
    getTeeAndPinStruct = function(self)

        const_addr_tee = 0x00E47EFC -- JP 0x00E47EFC
        const_addr_pin = 0x00EFD154 -- JP 0x00EFD154

        if self.state and self.state == true then

            -- Tee X, Y, Z
            self.tee[1] = readFloat(const_addr_tee)
            self.tee[2] = readFloat(const_addr_tee+4)
            self.tee[3] = readFloat(const_addr_tee+8)

            -- Pin X, Y, Z
            self.pin[1] = readFloat(const_addr_pin)
            self.pin[2] = readFloat(const_addr_pin+4)
            self.pin[3] = readFloat(const_addr_pin+8)

            if self.tee[1] and self.tee[2] and self.tee[3] and self.pin[1] and self.pin[2] and self.pin[3] then

                -- Calula distância
                self.distancia = math.sqrt(math.pow(self.tee[1]-self.pin[1], 2)+math.pow(self.tee[3]-self.pin[3], 2)) * 0.312495

                -- Format
                self.distancia = string.format('%0.2f', self.distancia)

                -- Calcula Altura
                self.altura = (self.pin[2] - self.tee[2] + 0.14) * (0.312495 * 0.914)

                -- Format
                self.altura = string.format('%0.2f', self.altura)
            end
        end
    end,
    getAnguloAndPowerBarStruct = function(self)

        const_addr_mira_sin = 0x00F024A0 -- JP 0x00F024A0

        if self.state and self.state == true then

            sin = readFloat(const_addr_mira_sin+8)
            cos = readFloat(const_addr_mira_sin)

            if sin and cos then

                -- Calcula Power Bar
                ang_cam = math.atan2(self.tee[1]-self.pin[1], self.tee[3]-self.pin[3])

                dist = math.sqrt(math.pow(self.tee[1]-self.pin[1], 2)+math.pow(self.tee[3]-self.pin[3], 2))

                if self.grid_mira_radiano &gt; 0 then

                    rad2 = readFloat(self.grid_mira_radiano)

                    rad = math.fmod(math.abs(rad2), 6.28318530717959)

                    if rad2 &lt; 0 then
                        rad = rad * -1
                    end

                    --self.pb = math.sin(rad + ang_cam) * dist * 0.9623
                    self.pb = (dist * 0.3125) * math.tan(rad + ang_cam) / 1.5 / 0.2167 * -1
                end

                -- Cacula Ângulo Mira
                graus_sin = tonumber(string.format('%.2f', math.deg(math.asin(sin))))
                graus_cos = tonumber(string.format('%.2f', math.deg(math.acos(cos))))

                if not graus_cos then
                    graus_cos = 0
                end

                if not graus_sin then
                    graus_sin = 0
                end

                if graus_sin &lt; 0.0 then
                    self.mira = 180.0 - (graus_cos - 180.0)
                else
                    self.mira = graus_cos
                end

                -- Disconta o ângulo do vento com o da mira
                self.mira = math.fmod(360 - ((self.mira - self.wind[2]) - 360), 360)
            end
        end

    end,
    getCurrentPlayer = function(self, addr_mngr, index)

        ret_curr_player = nil

        if addr_mngr ~= nil and addr_mngr ~= 0 then

            ptr = readInteger(addr_mngr + 0xC8)

            if ptr ~= nil and ptr ~= 0 then

                index_arr = readBytes('[' .. string.format("%x", self.const_addr_power_gauge) .. ']+10594', 1, false) -- JP +10594

                index_arr = index_arr - 4

                if (index_arr &gt;= 0 or index_arr &lt; 7) and (index_arr ~= 3 and index_arr ~= 4) then
                    ret_curr_player = ptr
                else

                    if (index &amp; 0xFF) &lt; readBytes(addr_mngr + 0xD5, 1, false) then

                        ret_curr_player = ptr + (index * 0xDB0) -- JP 0xDB0
                    end
                end
            end
        end

        return ret_curr_player
    end,
    getObjectPowerGaugePlayer = function(self, addr_mngr, index)

        ret_obj_power_gauge = nil

        if addr_mngr ~= nil and addr_mngr ~= 0 then

            ptr = readInteger(addr_mngr + 0xCC)

            if ptr ~= nil and ptr ~= 0 then
                ret_obj_power_gauge = ptr + (index * 0x3B4)
            end
        end

        return ret_obj_power_gauge
    end,
    getPowerGaugeObjectCurrentPlayer = function(self)

        -- 0x39C or 0x4C8 - Value
        -- 0x3A0 or 0x4CC - Mask
        -- 0x3A4 or 0x4D0 - Hash

        ret_obj_power_gauge = nil

        mngr = readInteger('[' .. string.format("%x", self.const_addr_power_gauge) .. ']+11024') -- JP +11024

        if mngr ~= nil and mngr ~= 0 then

            if readBytes('[' .. string.format("%x", self.const_addr_power_gauge) .. ']+10594', 1, false) == 1 then -- JP +10594

                player_index = readBytes(mngr + 0x189, 1, false) -- JP 0x189

                player = self:getCurrentPlayer(mngr, player_index)

                if player ~= nil and player ~= 0 then

                    power_gauge_index = readBytes(player + 0x4E9, 1, false) -- JP 0x4E9

                    power_gauge_obj = self:getObjectPowerGaugePlayer(mngr, power_gauge_index)

                    if power_gauge_obj ~= nil and power_gauge_obj ~= 0 then
                        ret_obj_power_gauge = power_gauge_obj + 0x39C
                    end
                end
            else

                player_index = readBytes(mngr + 0x189, 1, false) -- JP 0x189

                player = self:getCurrentPlayer(mngr, player_index)

                if player ~= nil and player ~= 0 then
                    ret_obj_power_gauge = player + 0x4C8 -- JP 0x4C8
                end
            end
        end

        return ret_obj_power_gauge
    end,
    getPowerGaugeStruct = function(self)

        -- Get Power Gauge
        power_gauge_obj = self:getPowerGaugeObjectCurrentPlayer()

        if power_gauge_obj ~= nil and power_gauge_obj ~= 0 then

            -- 0x00 value
            -- 0x04 mask
            -- 0x08 hash

            hash_power_gauge = readInteger(power_gauge_obj + 0x08) -- 0x08 Hash

            hash_power_gauge = ~(hash_power_gauge ~ readInteger(power_gauge_obj + 0x00)) &amp; 0xFFFFFFFF -- 0x00 Value

            self.power_gauge = byteTableToFloat(dwordToByteTable(hash_power_gauge))
        end
    end,
    changeWind = function(self, wind_speed, wind_direction, option)

        wind = self:getClassicWindStruct()

        if wind then

            wind:init(option)

            if wind.table_wind_value then

              if wind_speed and tonumber(wind_speed) then
                -- Update Wind Speed
                wind.table_wind_value.wind_speed = wind_speed
              end

              if wind_direction and tonumber(wind_direction) then
                -- Updat Wind Direction
                wind.table_wind_value.wind_direction = wind_direction
              end

              wind.table_wind_value:makeWindAndAng(wind.this)
            end
        else
            if option == 0 then
                print('Não conseguiu encontrar o Wind.')
            end
        end
    end,
    changePowerGauge = function(self, new_value)

        -- Set Power Gauge
        if new_value == nil then
            new_value = 99.0
        end

        if new_value ~= self.power_gauge then

            self.power_gauge = new_value;

            power_gauge_obj = self:getPowerGaugeObjectCurrentPlayer()

            if power_gauge_obj ~= nil and power_gauge_obj ~= 0 then

                -- 0x00 value
                -- 0x04 mask
                -- 0x08 hash

                hash_value = byteTableToDword(floatToByteTable(self.power_gauge))

                hash_value = (~hash_value &amp; 0xFFFFFFFF) ~ readInteger(power_gauge_obj + 0x08)

                mask = (power_gauge_obj + 0x00) ~ hash_value

                writeInteger(power_gauge_obj + 0x00, hash_value)
                writeInteger(power_gauge_obj + 0x04, mask)
            end
        end

    end,
    getSlopeBreak = function(self)

         const_addr_mira_sin = 0x00F024A0 -- JP 0x00F024A0

         sin = readFloat(const_addr_mira_sin+8)
         cos = readFloat(const_addr_mira_sin)

         -- Cacula Ângulo Mira
         graus_sin = tonumber(string.format('%.2f', math.deg(math.asin(sin))))
         graus_cos = tonumber(string.format('%.2f', math.deg(math.acos(cos))))

         if not graus_cos then
             graus_cos = 0
         end

         if not graus_sin then
             graus_sin = 0
         end

         mira = 0

         if graus_sin &lt; 0.0 then
             mira = 180.0 - (graus_cos - 180.0)
         else
             mira = graus_cos
         end

         -- Slope Break
         if self.grid_mira_radiano ~= nil and self.grid_mira_radiano ~= 0
            and self.ball_ground[1] ~= nil and self.ball_ground[1] ~= 0
            and self.ball_ground[2] ~= nil and self.ball_ground[2] ~= 0
            and sin ~= nil and sin ~= 0 and cos ~= nil and cos ~= 0
            and readFloat(self.grid_mira_radiano) ~= nil and readFloat(self.ball_ground[1]) ~= nil and readFloat(self.ball_ground[2]) ~= nil then

            -- atan2 = ang_cam
            mira_radiano = mira * 3.1415926535897932384626433832795 / 180

            --mira_radiano = math.fmod(mira_radiano, 3.1415926535897932384626433832795)

            mira_radiano = mira_radiano * -1

            cos = math.cos(mira_radiano)
            sin_neg = math.sin(mira_radiano) * -1

            --if math.deg(mira_radiano) ==

            -- ball_ground[] = [1] = X, [2] = Z
            return ((readFloat(self.ball_ground[1]) * cos) + (readFloat(self.ball_ground[2]) * sin_neg)) * -1 * (1 / 0.00875) --128
         end

         return 0.0
    end,
    makeAllRecord = function(self, option)
        sg = self:getSlopGroundStruct()
        s = self:getSpinStruct()
        wind = self:getClassicWindStruct()
        grid = self:getGridStruct()

        if sg then
           sg:init(option)

           -- Initialize data
           self.ground = sg.ground
           self.ball_ground[1] = sg.ground_x
           self.ball_ground[2] = sg.ground_y
           self.ball_line = sg.line_rotate
        else
            if option == 0 then
                showMessage('Não conseguiu encontrar o Slop Ground')
            end
        end

        if s then
           s:init(option)

           -- Initialize data
           self.ball_effect[1] = s.spin
           self.ball_effect[2] = s.curva
        else
            if option == 0 then
                showMessage('Não conseguiu encontrar o Spin')
            end
        end

        if wind then
            wind:init(option)

            -- Initialize data
            self.wind[1] = wind.wind_speed
            self.wind[2] = wind.wind_direction
            self.wind_rotate = wind.wind_rotate
        else
            if option == 0 then
                showMessage('Não conseguiu encontrar o Wind')
            end
        end

        -- Tee and Pin
        self:getTeeAndPinStruct()

        -- Grid esse tem o radianos da mira do player,
        -- esse tem que ser primeiro que o angulo e power bar por que ele usa no power bar
        if grid then

            grid:init()

            -- Initialize data
            self.grid_mira_radiano = grid.grid_mira_radiano
        else
            if option == 0 then
                showMessage('Não conseguiu encontrar o Grid')
            end
        end

        -- Ângulo Mira e Power Bar
        self:getAnguloAndPowerBarStruct()

        -- Get Power Gauge
        self:getPowerGaugeStruct()
    end
}

local search = MapSearch

-- Initialize
search:init()

-- Freeze values
local ball_line_rotate = {
    freeze = false,
    value = 0
}
local wind_rotate = {
    freeze = false,
    value = 0
}
local freeze_spin = {
    freeze = false,
    value = 0
}
local freeze_curva = {
    freeze = false,
    value = 0
}
local freeze_wind = {
    freeze = false,
    value = 0
}
local freeze_degree = {
    freeze = false,
    value = 0
}
local freeze_slope_x = {
    freeze = false,
    value = 0
}
local freeze_slope_y = {
    freeze = false,
    value = 0
}
local freeze_power_gauge_full = {
    freeze = false,
    value = 99.0
}
--
local edits = {
    spin = false,
    curva = false,
    vento = false,
    angulo = false,
    terreno = false,
    slope_x = false,
    slope_y = false
}
--

-- Hot Key Wind Rotate increse value
function increaseWindRotateValue(sender)

    if EditView.cbWindRotate.State and wind_rotate.freeze then

        -- Increase value by 0.25
        wind_rotate.value = wind_rotate.value + 0.25
    end
end

local wind_rotate_hk = createHotkey(increaseWindRotateValue, VK_CONTROL, VK_ADD)
--

RequiredCEVersion=6.5
if (getCEVersion==nil) or (getCEVersion()&lt;RequiredCEVersion) then
  messageDialog('Please install Cheat Engine '..RequiredCEVersion, mtError, mbOK)
  closeCE()
end
addresslist=getAddressList()

getAutoAttachList().add("ProjectG.exe")
EditView.show()

function Timer(sender)

    -- Update
    search:makeAllRecord()

    -- Rotação do vento
    if wind_rotate.freeze == false then

        -- Upadate
        wind_rotate.value = readFloat(search.wind_rotate)

    end

    -- Ball line roate
    if ball_line_rotate.freeze == false then

        -- Update
        ball_line_rotate.value = readFloat(search.ball_line)

    end

    -- Power gauge Full -- quando fazer o edit power gauge
    --if freeze_power_gauge_full.freeze == false then
    --end

    -- Spin e Curva

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.spin then

      spin = readFloat(search.ball_effect[1])

      if spin then
          EditView.eSpin.Text = string.format('%.2f', spin)
      else
          EditView.eSpin.Text = 0.00
      end

    end

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.curva then

      curva = readFloat(search.ball_effect[2])

      if curva then
          EditView.eCurva.Text = string.format('%.2f', curva)
      else
          EditView.eCurva.Text = 0.00
      end
    end

    -- Bola Slope

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.slope_x then

      slope_x = readFloat(search.ball_ground[1])

      if slope_x then
          EditView.eSlopeX.Text = string.format('%.9f', slope_x)
      else
          EditView.eSlopeX.Text = 0.00
      end
    end

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.slope_y then

      slope_y = readFloat(search.ball_ground[2])

      if slope_y then
          EditView.eSlopeY.Text = string.format('%.9f', slope_y)
      else
          EditView.eSlopeY.Text = 0.00
      end
    end

    -- Vento e Ângulo

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.vento then
        EditView.eWind.Text = search.wind[1]
    end

    if not edits.angulo then
        EditView.eDegree.Text = search.wind[2]
    end

    -- Terreno

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.terreno then
        -- Signed
        terreno = readInteger(search.ground)

        if terreno then
          if (terreno &amp; 0x80000000) &gt; 0 then
              terreno = ((~terreno &amp; 0xFFFFFFFF) + 1) * -1
          end

          EditView.lGround.Caption = string.format('%.0f', 100 - terreno)
        end
    end

    -- Distância
    EditView.lDistance.Caption = search.distancia

    -- Altura
    EditView.lAltura.Caption = search.altura 

    -- Power Bar
    EditView.lPB.Caption = string.format('%0.2f', search.pb)

    -- Ângulo Mira
    EditView.lDegreeAim.Caption = string.format('%0.2f', search.mira)

    -- Slope Break
    EditView.lSlope.Caption = string.format('%0.2f', search:getSlopeBreak())
end

function cbWindRotateChange(sender)

    if sender.State == cbChecked then

        -- Freeze Wind Rotate
        wind_rotate.freeze = true

        -- Set Timer
        EditView.tWindRotate.setOnTimer(tWindRotateTimer)
        EditView.tWindRotate.setEnabled(true)
    else
        -- Unfreeze Wind Rotate
        wind_rotate.freeze = false

        -- Unset Timer
        EditView.tWindRotate.setOnTimer(nil)
        EditView.tWindRotate.setEnabled(false)
    end
end

function cbBallLineChange(sender)

    if sender.State == cbChecked then

        -- Freeze Ball Line Rotate
        ball_line_rotate.freeze = true

        -- Set Timer
        EditView.tBallLineRotate.setOnTimer(tBallLineRotateTimer)
        EditView.tBallLineRotate.setEnabled(true)
    else
        -- Unfreeze Ball Line Rotate
        ball_line_rotate.freeze = false

        -- Unset Timer
        EditView.tBallLineRotate.setOnTimer(nil)
        EditView.tBallLineRotate.setEnabled(false)
    end
end

function cbPowerGaugeChange(sender)

    if sender.State == cbChecked then

        -- Freeze Power Gauge
        freeze_power_gauge_full.freeze = true

        freeze_power_gauge_full.value = 99.0 -- Full

        -- Set Timer
        EditView.tPowerGauge.setOnTimer(tPowerGaugeTimer)
        EditView.tPowerGauge.setEnabled(true)
    else
        -- Unfreeze Power Gauge
        freeze_power_gauge_full.freeze = false

        -- Unset Timer
        EditView.tPowerGauge.setOnTimer(nil)
        EditView.tPowerGauge.setEnabled(false)
    end
end

function btnPowerGaugeFullClick(sender)

     -- Change Power Gauge to 3 gauge full
     search:changePowerGauge(99.0)
end

function tWindRotateTimer(sender)

     -- Update (Freeze) mesmo value
     if search.wind_rotate ~= nil and search.wind_rotate ~= 0 then
        writeFloat(search.wind_rotate, wind_rotate.value)
     end
end

function tBallLineRotateTimer(sender)

    -- Update (Freeze) mesmo value
    if search.ball_line ~= nil and search.ball_line ~= 0 then
        writeFloat(search.ball_line, ball_line_rotate.value)
    end
end

function tPowerGaugeTimer(sender)

    -- Update (Freeze) mesmo value
    search:changePowerGauge(freeze_power_gauge_full.value)
end

-- Spin Freeze Methods
function cbSpinChange(sender)

    if sender.State == cbChecked then

        -- Freeze Spin
        freeze_spin.freeze = true

        -- Set Current Value
        if search.ball_effect[1] ~= nil and search.ball_effect[1] ~= 0 then
            freeze_spin.value = readFloat(search.ball_effect[1])
        end

        -- Set Timer
        EditView.tSpinFreeze.setOnTimer(tSpinFreezeTimer)
        EditView.tSpinFreeze.setEnabled(true)
    else
        -- Unfreeze Spin
        freeze_spin.freeze = false

        -- Unset Timer
        EditView.tSpinFreeze.setOnTimer(nil)
        EditView.tSpinFreeze.setEnabled(false)
    end
end

function tSpinFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    if search.ball_effect[1] ~= nil and search.ball_effect[1] ~= 0 then
        writeFloat(search.ball_effect[1], freeze_spin.value)
    end
end
-- End Spin Freeze Methods

-- Curva Freeze Methods
function cbCurvaChange(sender)

    if sender.State == cbChecked then

        -- Freeze Curva
        freeze_curva.freeze = true

        -- Set Current Value
        if search.ball_effect[2] ~= nil and search.ball_effect[2] ~= 0 then
            freeze_curva.value = readFloat(search.ball_effect[2])
        end

        -- Set Timer
        EditView.tCurvaFreeze.setOnTimer(tCurvaFreezeTimer)
        EditView.tCurvaFreeze.setEnabled(true)
    else
        -- Unfreeze Curva
        freeze_curva.freeze = false

        -- Unset Timer
        EditView.tCurvaFreeze.setOnTimer(nil)
        EditView.tCurvaFreeze.setEnabled(false)
    end
end

function tCurvaFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    if search.ball_effect[2] ~= nil and search.ball_effect[2] ~= 0 then
        writeFloat(search.ball_effect[2], freeze_curva.value)
    end
end
-- End Curva Freeze Methods

-- Slope X Freeze Methods
function cbSlopeXChange(sender)

    if sender.State == cbChecked then

        -- Freeze Slope X
        freeze_slope_x.freeze = true

        -- Set Current Value
        if search.ball_ground[1] ~= nil and search.ball_ground[1] ~= 0 then
            freeze_slope_x.value = readFloat(search.ball_ground[1])
        end

        -- Set Timer
        EditView.tSlopeXFreeze.setOnTimer(tSlopeXFreezeTimer)
        EditView.tSlopeXFreeze.setEnabled(true)
    else
        -- Unfreeze Slop X
        freeze_slope_x.freeze = false

        -- Unset Timer
        EditView.tSlopeXFreeze.setOnTimer(nil)
        EditView.tSlopeXFreeze.setEnabled(false)
    end
end

function tSlopeXFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    if search.ball_ground[1] ~= nil and search.ball_ground[1] ~= 0 then
        writeFloat(search.ball_ground[1], freeze_slope_x.value)
    end
end
-- End Slope X Freeze Methods

-- Slope Y Freeze Methods
function cbSlopeYChange(sender)

    if sender.State == cbChecked then

        -- Freeze Slope Y
        freeze_slope_y.freeze = true

        -- Set Current Value
        if search.ball_ground[2] ~= nil and search.ball_ground[2] ~= 0 then
            freeze_slope_y.value = readFloat(search.ball_ground[2])
        end

        -- Set Timer
        EditView.tSlopeYFreeze.setOnTimer(tSlopeYFreezeTimer)
        EditView.tSlopeYFreeze.setEnabled(true)
    else
        -- Unfreeze Slope Y
        freeze_slope_y.freeze = false

        -- Unset Timer
        EditView.tSlopeYFreeze.setOnTimer(nil)
        EditView.tSlopeYFreeze.setEnabled(false)
    end
end

function tSlopeYFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    if search.ball_ground[2] ~= nil and search.ball_ground[2] ~= 0 then
        writeFloat(search.ball_ground[2], freeze_slope_y.value)
    end
end
-- End Slope Y Freeze Methods

-- Wind Freeze Methods
function cbWindChange(sender)

    if sender.State == cbChecked then

        -- Freeze Wind
        freeze_wind.freeze = true

        -- Set Current Value
        freeze_wind.value = search.wind[1]

        -- Set Timer
        EditView.tWindFreeze.setOnTimer(tWindFreezeTimer)
        EditView.tWindFreeze.setEnabled(true)
    else
        -- Unfreeze Wind
        freeze_wind.freeze = false

        -- Unset Timer
        EditView.tWindFreeze.setOnTimer(nil)
        EditView.tWindFreeze.setEnabled(false)
    end
end

function tWindFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    search:changeWind(freeze_wind.value, nil, 1)
end
-- End Wind Freeze Methods

-- Degree Freeze Methods
function cbDegreeChange(sender)

    if sender.State == cbChecked then

        -- Freeze Degree
        freeze_degree.freeze = true

        -- Set Current Value
        freeze_degree.value = search.wind[2]

        -- Set Timer
        EditView.tDegreeFreeze.setOnTimer(tDegreeFreezeTimer)
        EditView.tDegreeFreeze.setEnabled(true)
    else
        -- Unfreeze Degree
        freeze_degree.freeze = false

        -- Unset Timer
        EditView.tDegreeFreeze.setOnTimer(nil)
        EditView.tDegreeFreeze.setEnabled(false)
    end
end

function tDegreeFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    search:changeWind(nil, freeze_degree.value, 1)
end
-- End Degree Freeze Methods

function eSpinKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) and search.ball_effect[1] ~= nil and search.ball_effect[1] ~= 0 then

            -- Set Freeze Value
            if freeze_spin.freeze then
                freeze_spin.value = tonumber(sender.Text)
            end

            writeFloat(search.ball_effect[1], tonumber(sender.Text))
        end

        -- Update state
        edits.spin = false
    else
        -- Update state
        edits.spin = true
    end

    return key
end

function eCurvaKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) and search.ball_effect[2] ~= nil and search.ball_effect[2] ~= 0 then

            -- Set Freeze Value
            if freeze_curva.freeze then
                freeze_curva.value = tonumber(sender.Text)
            end

            writeFloat(search.ball_effect[2], tonumber(sender.Text))
        end

        -- Update state
        edits.curva = false
    else
        -- Update state
        edits.curva = true
    end

    return key
end

function eDegreeKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) then

            -- Set Freeze Value
            if freeze_degree.freeze then
                freeze_degree.value = tonumber(sender.Text)
            end

            search:changeWind(nil, sender.Text, 1)
        end

        -- Update state
        edits.angulo = false
    else
        -- Update state
        edits.angulo = true
    end

    return key
end

function eWindKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) then

            -- Set Freeze Value
            if freeze_wind.freeze then
                freeze_wind.value = tonumber(sender.Text)
            end

            search:changeWind(sender.Text, nil, 1)
        end

        -- Update state
        edits.vento = false
    else
        -- Update state
        edits.vento = true
    end

    return key
end

function eSlopeXKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) and search.ball_ground[1] ~= nil and search.ball_ground[1] ~= 0 then

            -- Set Freeze Value
            if freeze_slope_x.freeze then
                freeze_slope_x.value = tonumber(sender.Text)
            end

            writeFloat(search.ball_ground[1], tonumber(sender.Text))
        end

        -- Update state
        edits.slope_x = false
    else
        -- Update state
        edits.slope_x = true
    end

    return key
end

function eSlopeYKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) and search.ball_ground[2] ~= nil and search.ball_ground[2] ~= 0 then

            -- Set Freeze Value
            if freeze_slope_y.freeze then
                freeze_slope_y.value = tonumber(sender.Text)
            end

            writeFloat(search.ball_ground[2], tonumber(sender.Text))
        end

        -- Update state
        edits.slope_y = false
    else
        -- Update state
        edits.slope_y = true
    end

    return key
end

function FormClose(sender)

    -- Destroy Hotkey
    if wind_rotate_hk then
        wind_rotate_hk.destroy()
        wind_rotate_hk = nil
    end

    closeCE()
    return caFree --Possible options: caHide, caFree, caMinimize, caNone
end
</LuaScript>
</CheatTable>
